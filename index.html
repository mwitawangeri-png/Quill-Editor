<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quill Editor Embebible</title>
    <link
      href="https://cdn.quilljs.com/1.3.7/quill.snow.css"
      rel="stylesheet" />
    <style>
      body {
        margin: 0;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: white;
      }

      .editor-container {
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .editor-toolbar {
        flex-shrink: 0;
        border-bottom: 1px solid #ba3f3f;
      }

      .editor-content {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      #editor {
        flex: 1;
        border: none;
      }

      .editor-actions {
        flex-shrink: 0;
        padding: 10px 15px;
        background: #f8f9fa;
        border-top: 1px solid #e0e0e0;
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }

      .editor-actions button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
        font-size: 14px;
        transition: all 0.2s;
      }

      .btn-save {
        background: #28a745;
        color: white;
      }

      .btn-save:hover {
        background: #218838;
      }

      .btn-delete {
        background: #dc3545;
        color: white;
        display: none !important;
      }

      .btn-delete:hover {
        background: #c82333;
      }

      .btn-save:disabled,
      .btn-delete:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .ql-variable {
        display: inline-flex;
        align-items: center;
        background: linear-gradient(135deg, #e3f2fd, #bbdefb) !important;
        color: #0d47a1 !important;
        font-weight: 600 !important;
        padding: 2px 8px !important;
        border-radius: 12px !important;
        margin: 0 2px !important;
        cursor: default !important;
        user-select: none !important;
        border: 1px solid #90caf9 !important;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important;
        transition: all 0.2s ease !important;
        white-space: nowrap !important;
        font-family: 'Consolas', monospace;
        font-size: 13px;
      }

      .ql-variable:hover {
        background: linear-gradient(135deg, #bbdefb, #90caf9) !important;
        transform: translateY(-1px) !important;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15) !important;
      }

      .ql-variable::before {
        font-size: 11px;
        margin-right: 4px;
        opacity: 0.8;
      }

      .ql-variable.type-number {
        background: linear-gradient(135deg, #fff3e0, #ffcc02) !important;
        border-color: #ff9800 !important;
        color: #e65100 !important;
      }

      .ql-variable.type-date {
        background: linear-gradient(135deg, #f3e5f5, #ce93d8) !important;
        border-color: #ab47bc !important;
        color: #4a148c !important;
      }

      .ql-variable.required {
        background: linear-gradient(135deg, #ffebee, #ffcdd2) !important;
        border-color: #ef5350 !important;
        color: #c62828 !important;
      }

      .ql-variable.required::after {
        content: ' *';
        color: #d32f2f;
        font-weight: bold;
      }

      @keyframes variableInsert {
        0% {
          transform: scale(0.8);
          opacity: 0.5;
        }
        50% {
          transform: scale(1.1);
        }
        100% {
          transform: scale(1);
          opacity: 1;
        }
      }

      .ql-variable.newly-inserted {
        animation: variableInsert 0.4s ease-out;
      }

      .ql-editor {
        font-size: 16px;
        line-height: 1.6;
      }
/* preview styling*/
      
.ql-preview-variable {
  display: inline-flex;
  align-items: center;
  background: linear-gradient(135deg, #e8f5e8, #c8e6c9) !important; /* Keep green color */
  color: #2e7d32 !important;
  font-weight: 600 !important; /* Match edit mode font weight */
  padding: 2px 8px !important;
  border-radius: 12px !important; /* Match edit mode border radius */
  margin: 0 2px !important; /* Match edit mode margin */
  cursor: default !important;
  user-select: none !important;
  border: 1px solid #4caf50 !important;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1) !important; /* Match edit mode shadow */
  transition: all 0.2s ease !important;
  white-space: nowrap !important;
  font-family: 'Consolas', monospace; /* Match edit mode font family */
  font-size: 13px; /* Match edit mode font size */
}

.ql-preview-variable:hover {
  background: linear-gradient(135deg, #c8e6c9, #a5d6a7) !important;
  transform: translateY(-1px) !important;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.15) !important; /* Match edit mode hover shadow */
}

.ql-preview-variable.type-number {
  background: linear-gradient(135deg, #e8f5e8, #c8e6c9) !important; /* Keep consistent green */
  border-color: #4caf50 !important;
  color: #2e7d32 !important;
}

.ql-preview-variable.type-date {
  background: linear-gradient(135deg, #e8f5e8, #c8e6c9) !important; /* Keep consistent green */
  border-color: #4caf50 !important;
  color: #2e7d32 !important;
}

.ql-preview-variable.required {
  background: linear-gradient(135deg, #ffebee, #ffcdd2) !important;
  border-color: #f44336 !important;
  color: #c62828 !important;
}

.ql-preview-variable.required::after {
  content: ' *';
  color: #d32f2f;
  font-weight: bold;
}

/* Remove the green container border in preview mode */
.editor-container.preview-mode {
  /* Remove border styling */
  border: none;
  border-radius: 0;
}

.editor-container.preview-mode .editor-toolbar {
  /* Remove green background from toolbar */
  background: inherit;
  border-bottom-color: #ba3f3f; /* Keep original border color */
}

/* Animation for newly inserted variables */
.ql-preview-variable.newly-inserted {
  animation: variableInsert 0.4s ease-out;
}
/* new styles */

  .editor-container.hide-toolbar .editor-content {
  padding-top: 15px;
}

.ql-editor[contenteditable="false"] {
  background-color: #f8f9fa !important;
  cursor: default !important;
}

.ql-editor[contenteditable="false"]:hover {
  background-color: #f8f9fa !important;
}

.variable-protected {
  position: relative;
}

.variable-protected::after {
  content: "🔒";
  position: absolute;
  top: -2px;
  right: -2px;
  font-size: 8px;
  opacity: 0.7;
}
      /* Hide save button when readonly */
.editor-container.readonly-mode .btn-save {
  display: none !important;
}
      .loading-indicator {
        display: none;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 20px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="editor-container">
      <div class="editor-toolbar" id="toolbar">
        <!-- Toolbar completo de Quill -->
        <span class="ql-formats">
          <select class="ql-font"></select>
          <select class="ql-size"></select>
        </span>
        <span class="ql-formats">
          <button class="ql-bold"></button>
          <button class="ql-italic"></button>
          <button class="ql-underline"></button>
          <button class="ql-strike"></button>
        </span>
        <span class="ql-formats">
          <select class="ql-color"></select>
          <select class="ql-background"></select>
        </span>
        <span class="ql-formats">
          <button class="ql-script" value="sub"></button>
          <button class="ql-script" value="super"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-header" value="1"></button>
          <button class="ql-header" value="2"></button>
          <button class="ql-blockquote"></button>
          <button class="ql-code-block"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-list" value="ordered"></button>
          <button class="ql-list" value="bullet"></button>
          <button class="ql-indent" value="-1"></button>
          <button class="ql-indent" value="+1"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-direction" value="rtl"></button>
          <select class="ql-align"></select>
        </span>
        <span class="ql-formats">
          <button class="ql-link"></button>
          <!-- <button class="ql-image"></button>
          <button class="ql-video"></button>
          <button class="ql-formula"></button> -->
        </span>
        <span class="ql-formats">
          <button class="ql-clean"></button>
        </span>
      </div>

      <div class="editor-content">
        <div id="editor"></div>
        <div class="loading-indicator" id="loadingIndicator">
          Cargando contenido...
        </div>
      </div>

      <div class="editor-actions">
        <button class="btn-save" id="saveBtn" onclick="handleSave()">
          Guardar
        </button>
        <button class="btn-delete" id="deleteBtn" onclick="handleDelete()">
          Eliminar
        </button>
      </div>
    </div>

    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>
    <script>
      // ========================================
      // CONFIGURACIÓN DEL BLOT DE VARIABLE
      // ========================================

      const Parchment = Quill.import('parchment');
      const Delta = Quill.import('delta'); // ADD THIS LINE
      class VariableBlot extends Parchment.Embed {
        static create(value) {
          const node = super.create();
          const varData =
            typeof value === 'string'
              ? { name: value, type: 'text', required: false, value: null }
              : value;

          // Configure nodo
          node.setAttribute('contenteditable', 'false');
          node.dataset.name = varData.name;
          node.dataset.type = varData.type;
          node.dataset.required = varData.required;
          
          // NEW: Store the value in the dataset
          node.dataset.value = varData.value || '';

          // Clases CSS
          node.classList.add('ql-variable');
          if (varData.type !== 'text')
            node.classList.add(`type-${varData.type}`);
          if (varData.required) node.classList.add('required');

          // Contenido - show variable name, not value
          node.textContent = varData.name;

          return node;
        }

        static value(node) {
          return {
            name: node.dataset.name,
            type: node.dataset.type,
            required: node.dataset.required === 'true',
            value: node.dataset.value || null // NEW: Include value in Delta
          };
        }
        
        static formats(node) {
          return this.value(node);
        }
      }

      VariableBlot.blotName = 'variable';
      VariableBlot.tagName = 'span';
      VariableBlot.className = 'ql-variable';
      Quill.register(VariableBlot);

      // ========================================
      // PREVIEW VARIABLE BLOT
      // ========================================

      class PreviewVariableBlot extends Parchment.Embed {
        static create(value) {
          const node = super.create();
          const varData = typeof value === 'string' 
            ? { name: value, type: 'text', required: false, displayValue: value }
            : value;

          node.setAttribute('contenteditable', 'false');
          node.dataset.name = varData.name;
          node.dataset.type = varData.type;
          node.dataset.required = varData.required;
          node.dataset.originalName = varData.name;

          node.classList.add('ql-preview-variable');
          if (varData.type !== 'text') node.classList.add(`type-${varData.type}`);
          if (varData.required) node.classList.add('required');

          node.textContent = varData.displayValue || varData.name;
          return node;
        }

        static value(node) {
          return {
            name: node.dataset.name,
            type: node.dataset.type,
            required: node.dataset.required === 'true',
            displayValue: node.textContent,
            originalName: node.dataset.originalName
          };
        }

        static formats(node) {
          return this.value(node);
        }
      }

      PreviewVariableBlot.blotName = 'previewVariable';
      PreviewVariableBlot.tagName = 'span';
      PreviewVariableBlot.className = 'ql-preview-variable';
      Quill.register(PreviewVariableBlot);

      // ========================================
      // FUNCIONES DE CODIFICACIÓN BASE64
      // ========================================
      function encodeBase64(content) {
        try {
          // Convertir el contenido Delta a JSON
          const jsonContent = JSON.stringify(content);
          // Codificar a Base64
          return btoa(unescape(encodeURIComponent(jsonContent)));
        } catch (error) {
          console.error('Error al codificar en Base64:', error);
          return null;
        }
      }

      function decodeBase64(base64String) {
        try {
          // Decodificar Base64
          const jsonContent = decodeURIComponent(escape(atob(base64String)));
          // Convertir JSON a objeto Delta
          return JSON.parse(jsonContent);
        } catch (error) {
          console.error('Error al decodificar Base64:', error);
          return null;
        }
      }

      // ========================================
      // FUNCIÓN PARA GENERAR UUID
      // ========================================
      function generateUUID() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
          /[xy]/g,
          function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
          }
        );
      }

      // ========================================
      // VARIABLES GLOBALES
      // ========================================
      let quillEditor;
      let editorId = null;
      let isContentLoaded = false;
      let documentUUID = null;
      let variableValues = {};
      let isPreviewMode = false;
      let originalContentBackup = null;
      let transformationMap = new Map();
      let targetPreviewMode = false;
      let isReadonly = false;
      let protectVariables = false;
      let hideToolbar = false;


      // ========================================
      // PREVIEW MODE FUNCTIONS
      // ========================================



      function enterPreviewMode() {
        if (isPreviewMode || !quillEditor) return false;
        
        console.log('=== ENTERING PREVIEW MODE ===');
        
        try {
          originalContentBackup = quillEditor.getContents();
          transformationMap.clear();
          
          const transformedOps = originalContentBackup.ops.map((op, index) => {
            if (op.insert && typeof op.insert === 'object' && op.insert.variable) {
              const variable = op.insert.variable;
              // Use value from Delta first, then fallback to variableValues
              const displayValue = variable.value || variableValues[variable.name] || `{{${variable.name}}}`;
              
              transformationMap.set(index, {
                originalVariable: variable,
                displayValue: displayValue
              });
              
              console.log(`Transforming variable: ${variable.name} -> ${displayValue}`);
              
              return {
                insert: {
                  previewVariable: {
                    name: variable.name,
                    type: variable.type,
                    required: variable.required,
                    displayValue: displayValue,
                    originalName: variable.name,
                    value: variable.value // Preserve original value
                  }
                }
              };
            }
            return op;
          });
          
          isContentLoaded = false;
          quillEditor.setContents(new Delta(transformedOps));
          isContentLoaded = true;
          
          isPreviewMode = true;
          updatePreviewModeUI();
          notifyPreviewModeChanged();
          
          console.log('=== PREVIEW MODE ENTERED SUCCESSFULLY ===');
          return true;
          
        } catch (error) {
          console.error('Error entering preview mode:', error);
          if (originalContentBackup) {
            quillEditor.setContents(originalContentBackup);
          }
          return false;
        }
      }

      function exitPreviewMode() {
        if (!isPreviewMode || !quillEditor || !originalContentBackup) return false;
        
        console.log('=== EXITING PREVIEW MODE ===');
        
        try {
          syncPreviewVariableChanges();
          
          isContentLoaded = false;
          quillEditor.setContents(originalContentBackup);
          isContentLoaded = true;
          
          isPreviewMode = false;
          originalContentBackup = null;
          transformationMap.clear();
          
          updatePreviewModeUI();
          notifyPreviewModeChanged();
          
          console.log('=== PREVIEW MODE EXITED SUCCESSFULLY ===');
          return true;
          
        } catch (error) {
          console.error('Error exiting preview mode:', error);
          return false;
        }
      }

      function applyCorrectModeFromURL() {
        console.log('=== APPLYING CORRECT MODE FROM URL ===');
        console.log('Current preview mode:', isPreviewMode);
        console.log('Target preview mode:', targetPreviewMode);
        
        if (targetPreviewMode && !isPreviewMode) {
          console.log('Switching to preview mode as requested by URL parameter');
          return enterPreviewMode();
        } else if (!targetPreviewMode && isPreviewMode) {
          console.log('Switching to edit mode as requested by URL parameter');
          return exitPreviewMode();
        }
        
        console.log('Already in correct mode, no change needed');
        return true;
      }

      function syncPreviewVariableChanges() {
        if (!isPreviewMode) return;
        
        console.log('=== SYNCING PREVIEW VARIABLE CHANGES ===');
        
        const currentContent = quillEditor.getContents();
        let hasChanges = false;
        
        currentContent.ops.forEach(op => {
          if (op.insert && typeof op.insert === 'object' && op.insert.previewVariable) {
            const previewVar = op.insert.previewVariable;
            const originalName = previewVar.originalName || previewVar.name;
            const currentDisplayValue = previewVar.displayValue;
            
            if (variableValues[originalName] !== currentDisplayValue) {
              console.log(`Variable value changed: ${originalName} = ${currentDisplayValue}`);
              variableValues[originalName] = currentDisplayValue;
              hasChanges = true;
            }
          }
        });
        
        if (hasChanges) {
          console.log('Variable values updated:', variableValues);
          notifyContentChanged();
        }
      }

      function updatePreviewModeUI() {
        const editorContainer = document.querySelector('.editor-container');
        if (editorContainer) {
          editorContainer.classList.toggle('preview-mode', isPreviewMode);
        }
        
        const saveBtn = document.getElementById('saveBtn');
        if (saveBtn) {
          saveBtn.textContent = isPreviewMode ? 'Guardar Vista' : 'Guardar';
        }
        
        console.log(`UI updated for ${isPreviewMode ? 'preview' : 'edit'} mode`);
      }

      function notifyPreviewModeChanged() {
        sendMessageToParent('preview-mode-changed', {
          editorId: editorId,
          uuid: documentUUID,
          isPreviewMode: isPreviewMode,
          timestamp: new Date().toISOString()
        });
      }

      function refreshPreviewMode() {
        if (!isPreviewMode) return false;
        
        console.log('=== REFRESHING PREVIEW MODE ===');
        exitPreviewMode();
        return enterPreviewMode();
      }

      // ===================================
      // NEW
      // ===================================

      function detectAdvancedFeaturesFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  
  // Existing edit mode detection
  const editMode = urlParams.get('editmode');
  targetPreviewMode = editMode === 'no';
  
  // New advanced features
  isReadonly = urlParams.get('readonly') === 'yes';
  protectVariables = urlParams.get('protectVariables') === 'yes';
  hideToolbar = urlParams.get('hideToolbar') === 'yes';
  
  console.log('=== ADVANCED FEATURES DETECTION ===');
  console.log('Edit mode (preview):', targetPreviewMode);
  console.log('Readonly mode:', isReadonly);
  console.log('Protect variables:', protectVariables);
  console.log('Hide toolbar:', hideToolbar);
  
  return {
    targetPreviewMode,
    isReadonly,
    protectVariables,
    hideToolbar
  };
}

function applyReadonlyMode() {
  if (!quillEditor) return;
  
  console.log('Applying readonly mode:', isReadonly);
  
  // Enable/disable editor
  quillEditor.enable(!isReadonly);
  
  // Visual feedback on editor
  const editorElement = document.querySelector('#editor .ql-editor');
  if (editorElement) {
    if (isReadonly) {
      editorElement.style.backgroundColor = '#f8f9fa';
      editorElement.style.cursor = 'default';
      editorElement.setAttribute('title', 'Editor is in read-only mode');
    } else {
      editorElement.style.backgroundColor = '';
      editorElement.style.cursor = '';
      editorElement.removeAttribute('title');
    }
  }
  
  // Add/remove readonly class to container (CSS will handle button hiding)
  const editorContainer = document.querySelector('.editor-container');
  if (editorContainer) {
    if (isReadonly) {
      editorContainer.classList.add('readonly-mode');
      console.log('✅ Added readonly-mode class - CSS will hide save button');
    } else {
      editorContainer.classList.remove('readonly-mode');
      console.log('✅ Removed readonly-mode class - save button will show');
    }
  }
}

function setupVariableProtection() {
  console.log('=== setupVariableProtection CALLED ===');
  console.log('protectVariables flag:', protectVariables);
  console.log('quillEditor exists:', !!quillEditor);
  
  if (!protectVariables) {
    console.log('❌ Variable protection disabled - protectVariables is false');
    return;
  }
  
  if (!quillEditor) {
    console.log('❌ Variable protection disabled - quillEditor not found');
    return;
  }
  
  console.log('✅ Setting up variable protection...');
  
  // Try the direct event listener approach
  const editorElement = document.querySelector('#editor .ql-editor');
  console.log('Editor element found:', !!editorElement);
  console.log('Editor element:', editorElement);
  
  if (editorElement) {
    console.log('Adding event listeners to editor element');
    
    editorElement.addEventListener('keydown', function(e) {
      console.log('🔑 Key pressed:', e.key);
      
      const selection = quillEditor.getSelection();
      if (!selection) {
        console.log('❌ No selection found');
        return;
      }
      
      console.log('📍 Selection:', selection);
      
      let shouldPrevent = false;
      
      if (e.key === 'Backspace') {
        console.log('⬅️ Checking Backspace at position:', selection.index - 1);
        shouldPrevent = isVariableAtPosition(selection.index - 1);
        console.log('🚫 Should prevent Backspace:', shouldPrevent);
      } else if (e.key === 'Delete') {
        console.log('➡️ Checking Delete at position:', selection.index);
        shouldPrevent = isVariableAtPosition(selection.index);
        console.log('🚫 Should prevent Delete:', shouldPrevent);
      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'x' && selection.length > 0) {
        console.log('✂️ Checking Cut operation for range:', selection.index, selection.length);
        shouldPrevent = hasVariableInRange(selection.index, selection.length);
        console.log('🚫 Should prevent Cut:', shouldPrevent);
      }
      
      if (shouldPrevent) {
        console.log('🛑 PREVENTING KEY ACTION');
        e.preventDefault();
        e.stopPropagation();
        
        // Visual feedback - flash red border
        const editorContainer = document.querySelector('.editor-container');
        if (editorContainer) {
          editorContainer.style.border = '3px solid #ff4444';
          setTimeout(() => {
            editorContainer.style.border = '';
          }, 300);
        }
        
        return false;
      }
    }, true); // Use capture phase
    
    console.log('✅ Event listeners added successfully');
    
    // Test the setup immediately
    setTimeout(() => {
      console.log('🧪 Testing variable protection setup...');
      debugVariableProtection();
    }, 1000);
    
  } else {
    console.log('❌ Could not find editor element');
    console.log('Available elements:', document.querySelector('#editor'));
  }
}

// ========================================
// ADD THESE DEBUG FUNCTIONS:
// ========================================

function debugVariableProtection() {
  console.log('=== VARIABLE PROTECTION DEBUG ===');
  console.log('protectVariables flag:', protectVariables);
  console.log('quillEditor exists:', !!quillEditor);
  
  if (quillEditor) {
    const contents = quillEditor.getContents();
    console.log('📄 Document contents:', contents);
    
    console.log('=== POSITION ANALYSIS ===');
    for (let i = 0; i < 10; i++) {
      const isVar = isVariableAtPosition(i);
      console.log(`Position ${i}: ${isVar ? '🔴 VARIABLE' : '⚪ text/empty'}`);
    }
  }
  
  const editorElement = document.querySelector('#editor .ql-editor');
  console.log('Editor element found:', !!editorElement);
}

function testPosition(index) {
  console.log(`🧪 Testing position ${index}:`, isVariableAtPosition(index));
}

// ========================================
// ENHANCED POSITION DETECTION
// ========================================
// REPLACE YOUR CURRENT isVariableAtPosition FUNCTION WITH THIS:

function isVariableAtPosition(index) {
  console.log('🔍 isVariableAtPosition called with index:', index);
  
  if (!quillEditor || index < 0) {
    console.log('❌ Invalid conditions - no editor or negative index');
    return false;
  }
  
  const contents = quillEditor.getContents();
  console.log('📄 Current document ops count:', contents.ops.length);
  
  let currentIndex = 0;
  
  for (let i = 0; i < contents.ops.length; i++) {
    const op = contents.ops[i];
    console.log(`📍 Processing op ${i}:`, op, 'at index', currentIndex);
    
    if (op.insert) {
      if (typeof op.insert === 'object') {
        // Check for variable or preview variable
        const hasVariable = !!(op.insert.variable || op.insert.previewVariable);
        const variableType = op.insert.variable ? 'variable' : (op.insert.previewVariable ? 'previewVariable' : 'other');
        
        console.log(`🎯 Found embed at index ${currentIndex}:`, variableType, hasVariable);
        
        if (hasVariable && currentIndex === index) {
          console.log('✅ MATCH! Variable found at target index', index);
          return true;
        }
        currentIndex += 1; // Embeds count as 1 character
      } else if (typeof op.insert === 'string') {
        const length = op.insert.length;
        console.log(`📝 Text from index ${currentIndex} to ${currentIndex + length - 1}: "${op.insert}"`);
        
        if (currentIndex <= index && index < currentIndex + length) {
          console.log('📝 Target index is within text content - not a variable');
          return false;
        }
        currentIndex += length;
      }
    }
  }
  
  console.log('❌ No variable found at index', index);
  return false;
}

// ========================================
// ALSO REPLACE hasVariableInRange:
// ========================================

function hasVariableInRange(startIndex, length) {
  console.log('🔍 hasVariableInRange called:', startIndex, 'length:', length);
  
  if (!quillEditor || length === 0) return false;
  
  for (let i = startIndex; i < startIndex + length; i++) {
    if (isVariableAtPosition(i)) {
      console.log('✅ Found variable in range at position', i);
      return true;
    }
  }
  
  console.log('❌ No variables found in range');
  return false;
}

function applyToolbarVisibility() {
  const toolbar = document.querySelector('.editor-toolbar');
  const editorContent = document.querySelector('.editor-content');
  
  if (toolbar && hideToolbar) {
    console.log('Hiding toolbar');
    toolbar.style.display = 'none';
    
    // Adjust editor content spacing
    if (editorContent) {
      editorContent.style.paddingTop = '15px';
    }
    
    // Add CSS class for styling
    document.querySelector('.editor-container')?.classList.add('hide-toolbar');
  } else if (toolbar) {
    toolbar.style.display = '';
    if (editorContent) {
      editorContent.style.paddingTop = '';
    }
    document.querySelector('.editor-container')?.classList.remove('hide-toolbar');
  }
}
         
      function animateNewVariable(varName) {
        const variableSelectors = ['.ql-variable', '.ql-preview-variable'];
        
        variableSelectors.forEach(selector => {
          const variables = document.querySelectorAll(selector);
          variables.forEach((varNode) => {
            if (varNode.dataset.name === varName || varNode.dataset.originalName === varName) {
              varNode.classList.add('newly-inserted');
              setTimeout(() => {
                varNode.classList.remove('newly-inserted');
              }, 400);
            }
          });
        });
      }

      // ========================================
      // INICIALIZACIÓN DEL EDITOR == replaced
      // ========================================
document.addEventListener('DOMContentLoaded', function () {
  quillEditor = new Quill('#editor', {
    theme: 'snow',
    modules: {
      toolbar: {
        container: '#toolbar',
        handlers: {},
      },
    },
    placeholder: 'Escribe tu documento aquí...',
  });

  // Configure toolbar
  const toolbar = quillEditor.getModule('toolbar');
  toolbar.addHandler('bold', () =>
    quillEditor.format('bold', !quillEditor.getFormat().bold)
  );

  // Events del editor
  quillEditor.on('text-change', function (delta, oldDelta, source) {
    if (source === 'user' && isContentLoaded && !isReadonly) {
      notifyContentChanged();
    }
  });

  // Get URL parameters and detect all features
  const urlParams = new URLSearchParams(window.location.search);
  editorId = urlParams.get('id');
  const base64Content = urlParams.get('content');
  documentUUID = urlParams.get('uuid');

  // DETECT ALL ADVANCED FEATURES
  detectAdvancedFeaturesFromURL();

  console.log('Document UUID:', documentUUID);
  console.log('Feature flags:', {
    targetPreviewMode,
    isReadonly,
    protectVariables,
    hideToolbar
  });

  // Apply advanced features
  applyToolbarVisibility();
  setupVariableProtection();

  if (base64Content) {
    showLoading(true);
    console.log('Setting content:', base64Content);
    window.editorAPI.setContent(base64Content);
    
    setTimeout(() => {
      applyCorrectModeFromURL();
      applyReadonlyMode(); // Apply after content is loaded
      showLoading(false);
    }, 200);
  } else {
    setTimeout(() => {
      applyCorrectModeFromURL();
      applyReadonlyMode(); // Apply immediately
    }, 100);
  }

  notifyEditorReady();
  window.addEventListener('message', handleParentMessage);
  isContentLoaded = true;
});

      // ========================================
      // API PÚBLICA DEL EDITOR
      // ========================================
      window.editorAPI = {
        insertVariable: function (name, type = 'text', required = false, value = null) {
          console.log('=== insertVariable API CALLED ===');
          console.log('Received name:', name);
          console.log('Received type:', type);
          console.log('Received required:', required);
          console.log('Received value:', value);
          console.log('Current preview mode:', isPreviewMode);

          if (!quillEditor) return false;

          const range = quillEditor.getSelection();
          const insertIndex = range ? range.index : quillEditor.getLength();

          try {
            // Store the value in variableValues AND in the Delta
            if (value !== null && value !== undefined && value !== '') {
              variableValues[name.trim()] = value;
              console.log(`Variable value stored: ${name.trim()} = ${value}`);
            }

            if (isPreviewMode) {
              const displayValue = variableValues[name.trim()] || `{{${name.trim()}}}`;
              quillEditor.insertEmbed(
                insertIndex,
                'previewVariable',
                {
                  name: name.trim(),
                  type: type,
                  required: required,
                  displayValue: displayValue,
                  originalName: name.trim(),
                  value: value // Include value in preview too
                },
                Quill.sources.API
              );
            } else {
              // Include value in the Delta
              quillEditor.insertEmbed(
                insertIndex,
                'variable',
                {
                  name: name.trim(),
                  type: type,
                  required: required,
                  value: value // This will be saved in Delta
                },
                Quill.sources.API
              );
            }

            quillEditor.setSelection(insertIndex + 1);
            setTimeout(() => animateNewVariable(name), 50);
            notifyContentChanged();

            return true;
          } catch (error) {
            console.error('Error al insertar variable:', error);
            return false;
          }
        },

        setContent: function (delta) {
          if (!quillEditor || !delta) return false;

          showLoading(true);

          try {
            isContentLoaded = false;

            // Si el contenido viene como Base64, decodificarlo primero
            const content =
              typeof delta === 'string' ? decodeBase64(delta) : delta;
            console.log('Contenido decodificdo ', content);
            quillEditor.setContents(content);

            setTimeout(() => {
              isContentLoaded = true;
              showLoading(false);
            }, 100);

            return true;
          } catch (error) {
            console.error('Error al establecer contenido:', error);
            showLoading(false);
            return false;
          }
        },

        getContent: function (encode = false) {
          if (!quillEditor) return null;
          const content = quillEditor.getContents();
          return encode ? encodeBase64(content) : content;
        },

        getHTML: function () {
          return quillEditor ? quillEditor.root.innerHTML : '';
        },

        getVariables: function() {
          if (!quillEditor) return [];
          
          const variables = [];
          const contents = quillEditor.getContents();
          
          contents.ops.forEach((op) => {
            let variable = null;
            
            if (op.insert && typeof op.insert === 'object') {
              if (op.insert.variable) {
                variable = op.insert.variable;
                // Value is now stored in Delta, but also sync with variableValues
                if (variable.value) {
                  variableValues[variable.name] = variable.value;
                }
              } else if (op.insert.previewVariable) {
                variable = {
                  name: op.insert.previewVariable.originalName || op.insert.previewVariable.name,
                  type: op.insert.previewVariable.type,
                  required: op.insert.previewVariable.required,
                  value: op.insert.previewVariable.displayValue
                };
                // Update variableValues from preview
                variableValues[variable.name] = op.insert.previewVariable.displayValue;
              }
              
              if (variable) {
                variables.push({
                  name: variable.name,
                  type: variable.type,
                  required: variable.required,
                  value: variable.value || variableValues[variable.name] || null
                });
              }
            }
          });
          
          return variables;
        },

        focus: function () {
          if (quillEditor) {
            quillEditor.focus();
            return true;
          }
          return false;
        },

        clear: function () {
          if (quillEditor) {
            quillEditor.setText('');
            return true;
          }
          return false;
        },

        getPreviewMode: function() {
          return isPreviewMode;
        },

        refreshPreviewMode: refreshPreviewMode,
        syncPreviewVariableChanges: syncPreviewVariableChanges,
        applyCorrectModeFromURL: applyCorrectModeFromURL
      };

      // ========================================
      // FUNCIONES DE COMUNICACIÓN CON EL PADRE
      // ========================================
      function notifyEditorReady() {
        sendMessageToParent('editor-ready', {
          editorId: editorId,
          uuid: documentUUID,
          api: Object.keys(window.editorAPI),
        });
      }

      function notifyContentChanged() {
        sendMessageToParent('content-changed', {
          editorId: editorId,
          uuid: documentUUID,
          content: window.editorAPI.getContent(true), // Codificado en Base64
          html: window.editorAPI.getHTML(),
          variables: window.editorAPI.getVariables(),
        });
      }

      function sendMessageToParent(type, data) {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage(
            {
              type: type,
              data: data,
              source: 'quill-editor',
            },
            '*'
          );
        }
      }

      function handleParentMessage(event) {
        if (!event.data || event.data.source !== 'quill-parent') return;

        const { type, data } = event.data;
        
        // ADD DEBUGGING
        console.log('=== IFRAME RECEIVED MESSAGE ===');
        console.log('Message type:', type);
        console.log('Message data:', data);

        switch (type) {
          case 'set-content':
            if (data.content) {
              window.editorAPI.setContent(data.content);
            }
            break;

          case 'insert-variable':
            if (data.name) {
              console.log('=== CALLING insertVariable ===');
              console.log('Name:', data.name);
              console.log('Type:', data.type || 'text');
              console.log('Required:', data.required || false);
              console.log('Value:', data.value || null);
              
              window.editorAPI.insertVariable(
                data.name,
                data.type || 'text',
                data.required || false,
                data.value || null
              );
            }
            break;

          case 'set-variable-values':
            if (data.values && typeof data.values === 'object') {
              Object.assign(variableValues, data.values);
              console.log('Variable values updated from parent:', variableValues);
              
              // If in preview mode, refresh to show new values
              if (isPreviewMode) {
                window.editorAPI.refreshPreviewMode();
              }
              
              sendMessageToParent('variable-values-updated', {
                editorId: editorId,
                uuid: documentUUID,
                variableValues: variableValues
              });
            }
            break;

          case 'apply-url-mode':
            // Allow parent to trigger mode application
            window.editorAPI.applyCorrectModeFromURL();
            break;

          case 'get-content':
            sendMessageToParent('content-response', {
              editorId: editorId,
              uuid: documentUUID,
              content: window.editorAPI.getContent(true), // Codificado en Base64
              html: window.editorAPI.getHTML(),
              variables: window.editorAPI.getVariables(),
            });
            break;

          case 'focus-editor':
            window.editorAPI.focus();
            break;

          case 'clear-editor':
            window.editorAPI.clear();
            break;
        }
      }

      // ========================================
      // FUNCIONES INTERNAS
      // ========================================

      function showLoading(show) {
        const indicator = document.getElementById('loadingIndicator');
        indicator.style.display = show ? 'block' : 'none';
      }

      // ========================================
      // MANEJADORES DE BOTONES
      // ========================================
      function handleSave() {
        const content = window.editorAPI.getContent(true); // Codificado en Base64
        const html = window.editorAPI.getHTML();
        const variables = window.editorAPI.getVariables();

        // Enviar datos al padre
        sendMessageToParent('save-requested', {
          editorId: editorId,
          uuid: documentUUID,
          content: content,
          html: html,
          variables: variables,
          timestamp: new Date().toISOString(),
        });

        // Feedback visual
        const saveBtn = document.getElementById('saveBtn');
        const originalText = saveBtn.innerHTML;
        saveBtn.innerHTML = '✅ Guardado';
        saveBtn.disabled = true;

        setTimeout(() => {
          saveBtn.innerHTML = originalText;
          saveBtn.disabled = false;
        }, 2000);
      }

      function handleDelete() {
        if (confirm('¿Estás seguro de que deseas eliminar este documento?')) {
          sendMessageToParent('delete-requested', {
            editorId: editorId,
            uuid: documentUUID,
            timestamp: new Date().toISOString(),
          });

          // Feedback visual
          const deleteBtn = document.getElementById('deleteBtn');
          const originalText = deleteBtn.innerHTML;
          deleteBtn.innerHTML = '🗑️ Eliminando...';
          deleteBtn.disabled = true;

          // El padre decidirá si realmente eliminar o no
          setTimeout(() => {
            deleteBtn.innerHTML = originalText;
            deleteBtn.disabled = false;
          }, 3000);
        }
      }

      // ========================================
      // ATAJOS DE TECLADO
      // ========================================
      document.addEventListener('keydown', function (e) {
        // Ctrl/Cmd + S para guardar
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          handleSave();
        }

        // Ctrl/Cmd + Shift + V para insertar variable rápida
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'V') {
          e.preventDefault();
          const varName = prompt('Nombre de la variable:');
          if (varName) {
            window.editorAPI.insertVariable(varName);
          }
        }
      });

      // ========================================
      // PREVENIR PÉRDIDA DE DATOS
      // ========================================
      window.addEventListener('beforeunload', function (e) {
        if (quillEditor && quillEditor.getText().trim().length > 0) {
          e.preventDefault();
          e.returnValue = '';
          return '';
        }
      });
    </script>
  </body>
</html>
